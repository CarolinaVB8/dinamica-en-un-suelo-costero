---
title: "Relación entre las variables meteorológicas con la salinidad de un suelo en la Región de Los Lagos"
author: 
  - name: Carolina Vargas
    email: carolina.vargas.b@ug.uchile.cl
date: "12/05/2025"
toc: true
format: 
  html:
    self-contained: true
    code-fold: true
    code-summary: "Code"
editor: visual
execute: 
  warning: false
  message: false
---

```{css, echo = FALSE}
.justify {
  text-align: justify !important
}
```

## Introducción

A nivel mundial, los suelos costeros están experimentando un mayor nivel de salinidad por la intrusión marina. Este proceso está potenciado principalmente por el aumento del nivel del mar, sin embargo, **¿existirán otras variables que se correlacionen y determinen una mayor salinidad del suelo?**

Este trabajo tiene como objetivo: *Analizar el efecto de las variables meteorológicas (como la precipitación, temperatura, velocidad y dirección del viento) en la salinidad de un suelo de la Región de Los Lagos.*

## Metodología

Para llevar a cabo la investigación, se utilizaron los datos obtenidos de los siguientes instrumentos (ambos entregan datos cada 15 minutos):

• Estación meteorológica ATMOS-41, diseñadas para el monitoreo continuo de variables meteorológicas como la temperatura del aire, precipitación y velocidad del viento.

• Sensor TEROS-12 (Decagon Devices), que medirán la conductividad eléctrica del suelo.

## Resultados

A continuación se presentan los resultados obtenidos:

### Preprocesamiento

En primer lugar se cargaron los datos

```{r}
#CARGA DE DATOS
# Se utiliza librería readxl ya que contamos con datos .xlsx

#Cargar librerias
library(readxl)

#Cargar datos
estacion <- read_xlsx("datos/raw/Estacion_meteorologica.xlsx")
teros <- read_xlsx("datos/raw/Teros-12_20cm.xlsx")

```

Luego, se realizó un análisis exploratorio donde se visualizaron los tipos de variable que correspondía cada columna de la base de datos y se ajustaron los nombres de las columnas para trabajar de manera más directa y clara.

```{r}
#EXPLORAR DATOS
# Fase inicial para conocer qué tipo de datos tenemos en nuestro poder
# Para trabajar los datos fue necesario convertir los valores de EC a numerico
# Se utilizó el codigo enseñado en clases 

# Cargar librerías necesarias
library(readxl)
library(dplyr)
library(lubridate)
library(janitor)

#Explorar datos
glimpse(estacion)
glimpse(teros)

#Ajustar tipo de dato de cada variable (en este caso la EC está en booleano y lo cambiamos a numerico)
teros <- teros %>%
  mutate(mS_cm_EC = as.numeric(`mS/cm Saturation Extract EC`))

#Dejar todos los nombres depurados (más facil su utilización)
estacion <- estacion %>%
  clean_names()
teros <- teros %>%
  clean_names()

#Eliminamos columnas de teros que no usaremos
teros <- teros[,-c(2,3,4,5,6)] #solo nos quedamos con timestamps (fecha y hora) y EC

```

Posteriormente, se desarrolló un procesamiento de datos donde se siguieron los siguientes pasos:

1.  Unión de datos de ambas bases de datos a partir de la columna en común de fecha y hora, asegurándonos que esa columna correspondiera a una variable tipo fecha

2.  Eliminación de datos que presentaban "NA", con el fin de obtener una base de datos completa para así facilitar los análisis posteriores

3.  Agregación de datos a nivel diario

4.  Obtención de nuevo archivo con los datos depurados

```{r}
# PROCESAMIENTO DE DATOS
# Una vez comprendidas las variables presentes en los datos, se procede al procesamiento de estos
# Se utilizó el codigo enseñado en clases 
# Se usó chatgpt para depurar, ordenar, modificar y optimizar los códigos propuestos inicialmente

# Cargar librerías necesarias
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)

# ============================================================================
# 1. PREPARACIÓN DE TIMESTAMPS
# ============================================================================
# Convertir columna fecha a formato fecha 
convertir_fecha <- function(x) {
  fecha <- as.POSIXct(x, format = "%d-%m-%Y", tz = "UTC")
    error = function(e) NULL
  return(fecha)
}

# ============================================================================
# 2. UNIÓN DE DATOS POR TIMESTAMPS
# ============================================================================
datos_completos <- merge(estacion, teros, by = "timestamps", all = TRUE)

# Identificar columnas de variables meteorológicas y CE
columnas_meteo <- c("mm_precipitation", "m_s_wind_speed", "c_air_temperature")
columnas_ce <- c("m_s_cm_ec")

# ============================================================================
# 3. ELIMINACIÓN DE FILAS SIN DATOS
# ============================================================================
# Contar NAs por fila
datos_completos$na_count_meteo <- rowSums(is.na(datos_completos[, columnas_meteo, drop = FALSE]))
datos_completos$na_count_ce <- rowSums(is.na(datos_completos[, columnas_ce, drop = FALSE]))

# Eliminar filas donde:
# 1. No hay datos de CE (todas las columnas de CE son NA)
# 2. No hay datos de variables meteorológicas (todas son NA)
datos_limpios <- datos_completos %>%
  filter(na_count_ce == 0) %>%  # Al menos una columna de CE tiene datos
  filter(na_count_meteo == 0)  # Al menos una variable meteo tiene datos

# Eliminar columnas auxiliares de conteo
datos_limpios <- datos_limpios %>%
  select(-na_count_meteo, -na_count_ce)

# Verificar porcentaje de datos completos
cat("\n=== RESUMEN DE DATOS COMPLETOS ===\n")
for (col in c(columnas_meteo, columnas_ce)) {
  if (col %in% names(datos_limpios)) {
    pct_completo <- (1 - sum(is.na(datos_limpios[[col]])) / nrow(datos_limpios)) * 100
    cat(sprintf("%s: %.1f%% de datos completos\n", col, pct_completo))
  }
}

# ============================================================================
# 4. AGREGACIÓN DIARIA DE DATOS
# ============================================================================
# Se aplicará sumatoria para precipitación y promedio para el resto de variables
# Precipitación: suma diaria
col_precip <- "mm_precipitation"
# Resto: promedio diario
cols_promedio <- c("c_air_temperature", "m_s_wind_speed", "m_s_cm_ec")

datos_limpios <- datos_limpios%>%
  mutate(fecha = as.Date(timestamps))

# Agregar datos por día
datos_diarios <- datos_limpios %>%
  group_by(fecha) %>%
  summarise(
    # Precipitación: suma diaria
    !!col_precip := sum(!!sym(col_precip), na.rm = TRUE),
    
    # Temperatura: promedio diario
    !!cols_promedio[1] := mean(!!sym(cols_promedio[1]), na.rm = TRUE),
    
    # Velocidad del viento: promedio diario
    !!cols_promedio[2] := mean(!!sym(cols_promedio[2]), na.rm = TRUE),
    
    # CE del suelo: promedio diario
    !!cols_promedio[3] := mean(!!sym(cols_promedio[3]), na.rm = TRUE),
    
    # Contar número de observaciones por día (para validación)
    n_obs = n(),
    
    .groups = "drop"
  ) %>%
    # Eliminar días donde todas las variables son NA o 0 (precipitación puede ser 0)
  filter(
    !is.na(!!sym(cols_promedio[1])) |  # Al menos temperatura tiene datos
    !is.na(!!sym(cols_promedio[2])) |  # O velocidad del viento
    !is.na(!!sym(cols_promedio[3]))    # O CE
  )

# Reemplazar datos_limpios con datos_diarios para el resto del análisis
datos_limpios <- datos_diarios %>%
  select(-n_obs)  # Eliminar columna auxiliar

# Actualizar columnas para el resto del análisis
columnas_meteo <- c(col_precip, cols_promedio[1], cols_promedio[2])
columnas_ce <- cols_promedio[3]

# ============================================================================
# 5. CREAR VARIABLES TEMPORALES PARA ANÁLISIS
# ============================================================================
datos_limpios <- datos_limpios %>%
  mutate(
    Año = year(fecha),
    Mes = month(fecha, label = TRUE, abbr = FALSE),
    Mes_num = month(fecha),
    Estacion = case_when(
      month(fecha) %in% c(12, 1, 2) ~ "Verano",
      month(fecha) %in% c(3, 4, 5) ~ "Otoño",
      month(fecha) %in% c(6, 7, 8) ~ "Invierno",
      month(fecha) %in% c(9, 10, 11) ~ "Primavera"
    ),
    Estacion = factor(Estacion, levels = c("Verano", "Otoño", "Invierno", "Primavera"))
  )

write_xlsx(datos_limpios, "Variables_y_EC.xlsx")
```

### Gráficos

A continuación se muestra cada uno de los códigos y el respectivo paso a paso para obtener los gráficos

#### *Variabilidad de datos meteorológicos*

Para obtener las gráficas de boxplot asociadas a cada una de las variables ambientales, se realizó lo siguiente:

1.  Identificación de las variables con nombres y unidades de medidas claras
2.  Creación de columnas de temporalidad necesaria para llevar a cabo cada boxplot mensual
3.  Creación de función para construir boxplot para las 3 variables
4.  Consideraciones adicionales respecto a la variable de precipitación que presentaba un outlier muy alto que distorsionaba la gráfica. En este caso se aplicó una transformación de rangos y se creó un quiebre en la gráfica
5.  Combinación de las 3 gráficas para generar una única imagen en .png

![](figuras/Figura1_Boxplots_Mensuales.png)

```{r eval=FALSE}
# ANALISIS DE LA VARIABILIDAD DE LAS VARIABLES METEOROLOGICAS
# Se procedió a realizar gráficos boxplot por cada variable meteorologica
# Se utilizó el codigo enseñado en clases 
# Se usó chatgpt para depurar, ordenar, modificar y optimizar los códigos propuestos inicialmente

# Librerías
library(dplyr)
library(ggplot2)
library(lubridate)
library(gridExtra)
library(rlang)
library(patchwork)

# ============================================================================
# NOMBRES DE COLUMNAS
# ============================================================================
# Títulos por cada gráfico
labels_info <- list(
  mm_precipitation = list(title = "Variabilidad de la precipitación dentro de cada mes", y = "Precipitación (mm)"),
  m_s_wind_speed   = list(title = "Variabilidad de la velocidad del viento dentro de cada mes", y = "Velocidad del viento (m/s)"),
  c_air_temperature = list(title = "Variabilidad de la temperatura del aire dentro de cada mes", y = "Temperatura del aire (°C)"))

# colores: celeste (precip), naranjo (temp), verde (viento)
col_map <- c(mm_precipitation = "#7fc9ff",  # celeste
             c_air_temperature = "#ff9f40", # naranjo
             m_s_wind_speed = "#6bbf59")    # verde

# Parámetros del quiebre, con el fin de ver un gráfico más compacto (en este caso, precipitacion presenta un outlier de 92.359 que distorsiona todo el gráfico)
quiebre_limite <- 25 # número donde comienza el quiebre
factor_compresion <- 0.05 
max_precipitacion <- 95  # valor máximo del eje Y para precipitación

# ============================================================================
# PREPARAR DATOS: asegurar columnas temporales necesarias
# ============================================================================
datos_limpios <- datos_limpios %>%
  mutate(
    Año = year(fecha),
    Mes_num = month(fecha),
    Mes_Año = paste0(Año, "-", sprintf("%02d", Mes_num)),
    Mes = month(fecha, label = TRUE, abbr = FALSE))

# ============================================================================
# FUNCIÓN BOXPLOT MENSUAL (usa quiebre solo si quiebre = TRUE)
# ============================================================================
crear_boxplot_mensual <- function(datos, variable, titulo, etiqueta_y,
                                  quiebre = FALSE, quiebre_limite = 25, factor_compresion = 0.05, max_y = NULL, fill_color = "steelblue") {
  var_sym <- sym(variable)
  
  datos_filtrados <- datos %>%
    filter(!is.na(!!var_sym), !is.na(Mes_Año))
  
  if (nrow(datos_filtrados) == 0) return(NULL)
  
  # Meses ordenados y etiquetas (solo nombre del mes, sin año)
  meses <- datos_filtrados %>%
    select(Mes_Año, Mes_num, Año, Mes) %>%
    distinct() %>%
    arrange(Año, Mes_num) %>%
    mutate(
      Mes_factor = factor(Mes_Año, levels = unique(Mes_Año), ordered = TRUE),
      Etiqueta_mes = as.character(Mes))
  
  datos_filtrados <- datos_filtrados %>%
    left_join(meses, by = c("Mes_Año", "Mes_num", "Año", "Mes")) %>%
    mutate(Mes_factor = factor(Mes_Año, levels = levels(meses$Mes_factor), ordered = TRUE))
  
  # Conteo por mes para etiquetas X
  n_obs <- datos_filtrados %>%
    group_by(Mes_Año, Etiqueta_mes) %>%
    summarise(n = n(), .groups = "drop") %>%
    arrange(match(Mes_Año, levels(meses$Mes_factor)))
  etiquetas_x <- paste0(n_obs$Etiqueta_mes, "\n(n=", n_obs$n, ")")
  
  # Si hay quiebre: transformar valores
  if (quiebre) {
    datos_filtrados <- datos_filtrados %>%
      mutate(valor_original = !!var_sym,
             valor_transformado = ifelse(valor_original <= quiebre_limite,
                                         valor_original,
                                         quiebre_limite + 1 + (valor_original - quiebre_limite) * factor_compresion))
    y_var <- "valor_transformado"
    
    # Si se especifica max_y, usar ese valor transformado; si no, usar el máximo real
    if (!is.null(max_y)) {
      y_top <- ifelse(max_y <= quiebre_limite,
                      max_y,
                      quiebre_limite + 1 + (max_y - quiebre_limite) * factor_compresion) * 1.05
    } else {
      y_top <- max(datos_filtrados$valor_transformado, na.rm = TRUE) * 1.05
    }
  } else {
    datos_filtrados <- datos_filtrados %>% mutate(valor_original = !!var_sym)
    y_var <- "valor_original"
    y_top <- max(datos_filtrados$valor_original, na.rm = TRUE) * 1.05}
  
  # Precipitación acumulada mensual (si corresponde)
  anot_precip <- NULL
  if (variable == "mm_precipitation" && "mm_precipitation" %in% names(datos)) {
    anot_precip <- datos_filtrados %>%
      group_by(Mes_Año, Etiqueta_mes) %>%
      summarise(Precip_acum = sum(mm_precipitation, na.rm = TRUE), .groups = "drop") %>%
      arrange(match(Mes_Año, levels(meses$Mes_factor)))}
  
  # Medianas por mes (sobre valores originales)
  medianas <- datos_filtrados %>%
    group_by(Mes_Año) %>%
    summarise(med = median(valor_original, na.rm = TRUE), .groups = "drop")
  
  # Construir ggplot
  p <- ggplot(datos_filtrados, aes(x = Mes_factor, y = .data[[y_var]])) +
    geom_boxplot(fill = fill_color, alpha = 0.7,
                 outlier.size = 1.5, outlier.alpha = 0.6,
                 outlier.color = "red", outlier.stroke = 0.5) +
    labs(title = titulo,
         subtitle = paste0("Período: ", min(datos_filtrados$fecha), " a ", max(datos_filtrados$fecha)),
         x = "Mes", y = etiqueta_y) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 20, face = "bold"),
          plot.subtitle = element_text(hjust = 0.5, size = 14, color = "gray40", face = "italic"),
          axis.text.x = element_text(angle = 0, hjust = 0.5, size = 14, face = "bold"),
          axis.text.y = element_text(size = 13),
          axis.title = element_text(size = 14, face = "bold"),
          panel.grid.major.x = element_blank(),
          panel.grid.minor = element_blank(),
          plot.margin = margin(t = 5, r = 5, b = 25, l = 5)) +
    scale_x_discrete(labels = etiquetas_x, drop = FALSE) +
    ylim(0, y_top)
  
  # Mediana como texto
  p <- p + geom_text(data = medianas, aes(x = Mes_Año, y = y_top * 0.99, label = paste0("Med=", round(med,2))),
                     inherit.aes = FALSE, size = 4, color = "darkblue", vjust = 1)
  
  # Líneas y marcas de quiebre (si aplica)
  if (quiebre) {
    # Usar max_y si está especificado, si no usar el máximo real
    max_real <- ifelse(!is.null(max_y), max_y, max(datos_filtrados$valor_original, na.rm = TRUE))
    
    # Crear breaks hasta max_real
    breaks_inferior <- seq(0, quiebre_limite, by = 5)
    breaks_superior <- seq(95, max_real, by = 5)
    
    # Transformar breaks superiores
    breaks_superior_transformados <- quiebre_limite + 1 + (breaks_superior - quiebre_limite) * factor_compresion
    
    # Labels correspondientes
    labels_inferior <- as.character(breaks_inferior)
    labels_superior <- as.character(breaks_superior)
    
    p <- p +
      scale_y_continuous(
        limits = c(0, y_top),
        breaks = c(breaks_inferior, breaks_superior_transformados),
        labels = c(labels_inferior, labels_superior)
      ) +
      # Líneas de quiebre
      annotate("segment",
               x = -Inf, xend = Inf,
               y = quiebre_limite + 1, yend = quiebre_limite + 1,
               linetype = "dashed", color = "grey", size = 1.2) +
      annotate("segment",
               x = -Inf, xend = Inf,
               y = quiebre_limite, yend = quiebre_limite,
               linetype = "dashed", color = "grey", size = 1.2)
    }
  
  # Anotación de precip acumulada por mes (arriba)
  if (!is.null(anot_precip) && nrow(anot_precip) > 0) {
    pos_y <- y_top * 1
    for (i in seq_len(nrow(anot_precip))) {
      x_idx <- which(levels(datos_filtrados$Mes_factor) == anot_precip$Mes_Año[i])
      if (length(x_idx)) {
        p <- p + annotate("text", x = x_idx, y = pos_y,
                          label = paste0("\u03A3=", round(anot_precip$Precip_acum[i],1), " mm"),
                          size = 4, color = "darkgreen", fontface = "bold", vjust = 0)
      }
    }
  }
  
  return(p)
}

# ============================================================================
# GENERAR PLOTS SEGUN COLUMNAS DISPONIBLES
# ============================================================================
plots_mensuales <- list()
for (var in columnas_meteo) {
  if (!var %in% names(datos_limpios)) next
  info <- labels_info[[var]]
  if (is.null(info)) info <- list(title = var, y = var)
  color <- col_map[[var]] %||% "steelblue"
  
  if (var == "mm_precipitation") {
    p <- crear_boxplot_mensual(datos_limpios, var, info$title, info$y,
                               quiebre = TRUE, quiebre_limite = quiebre_limite, 
                               factor_compresion = factor_compresion, max_y = max_precipitacion, fill_color = color)
  } else {
    p <- crear_boxplot_mensual(datos_limpios, var, info$title, info$y, quiebre = FALSE, fill_color = color)
  }
  
  if (!is.null(p)) plots_mensuales[[var]] <- p
}

# ============================================================================
# COMBINAR Y GUARDAR FIGURA
# ============================================================================
if (length(plots_mensuales) > 0) {
  plots_ordered <- plots_mensuales[intersect(columnas_meteo, names(plots_mensuales))]
  figura_final <- do.call(grid.arrange, c(plots_ordered, ncol = 1))
  ggsave("Figura1_Boxplots_Mensuales.png", figura_final, width = 14, height = 6 * length(plots_ordered), dpi = 300)
} else {
  message("No se generaron plots: revisa que datos_limpios tenga las columnas y datos.")
}

```

#### *Evolución temporal entre las variables meteorológicas y la conductividad eléctrica del suelo*

A partir del siguiente código, se generaron gráficas de líneas que mostraban la evolución temporal de las variables. Para esto se realizaron los siguientes pasos:

1.  Identificación de las variables con nombres y unidades de medidas claras, además de colores asociados a cada una
2.  Creación de función para construir gráfico de líneas entre una variable meteorológica y la conductividad eléctrica
3.  Combinación de las 3 gráficas para generar una única imagen en .png

![](figuras/Figura2_Series_Temporales_Superpuestas.png)

```{r}
# EVOLUCIÓN DE LAS VARIABLES METEOROLÓGICAS VS CONDUCTIVIDAD ELÉCTRICA
# Se procedió a realizar gráficos de línea por el cruce entre variable con CE
# Se utilizó el codigo enseñado en clases 
# Se usó chatgpt para depurar, ordenar, modificar y optimizar los códigos propuestos inicialmente

#Cargar librerías
library(ggplot2)
library(patchwork)
library(scales)

# ============================================================================
# NOMBRES DE COLUMNAS
# ============================================================================
labels_vars <- list(
  mm_precipitation  = c(nombre = "Precipitación", unidad = "mm", nombre_completo = "Precipitación (mm)"),
  m_s_wind_speed    = c(nombre = "Velocidad del Viento", unidad = "m/s", nombre_completo = "Velocidad del Viento (m/s)"),
  c_air_temperature = c(nombre = "Temperatura del Aire", unidad = "°C", nombre_completo = "Temperatura del Aire (°C)"),
  m_s_cm_ec         = c(nombre = "Conductividad Eléctrica", unidad = "mS/cm", nombre_completo = "Conductividad Eléctrica (mS/cm)"))

get_label <- function(name) {
  lbl <- labels_vars[[name]]
  if (is.null(lbl)) return(c(nombre = name, unidad = "", nombre_completo = name))
  return(lbl)
}

# Mapa de colores fijo solicitado
color_map <- c(
  mm_precipitation  = "#7fc9ff",  # celeste
  m_s_wind_speed    = "#6bbf59",  # verde
  c_air_temperature = "#ff9f40",  # naranja
  m_s_cm_ec         = "#000000"   # negro
)

# ============================================================================
# FUNCIÓN GRÁFICO DE LÍNEAS
# ============================================================================
crear_series_temporales <- function(df, var_meteo, var_ce) {
  
  lbl_m <- get_label(var_meteo)
  lbl_c <- get_label(var_ce)
  
  nombre_m <- as.character(lbl_m["nombre"])
  nombre_c <- as.character(lbl_c["nombre"])
  
  dfp <- df %>%
    select(fecha, !!sym(var_meteo), !!sym(var_ce)) %>%
    arrange(fecha) %>%
    filter(!is.na(!!sym(var_meteo)) | !is.na(!!sym(var_ce)))
  if (nrow(dfp) == 0) return(NULL)
  
  # calcular período para subtítulo
  fecha_min <- format(min(dfp$fecha, na.rm = TRUE), "%Y-%m-%d")
  fecha_max <- format(max(dfp$fecha, na.rm = TRUE), "%Y-%m-%d")
  subtitulo  <- paste0("Período: ", fecha_min, " a ", fecha_max)
  
  # escala
  rango_m <- range(dfp[[var_meteo]], na.rm = TRUE)
  rango_c <- range(dfp[[var_ce]], na.rm = TRUE)
  factor_escala <- ifelse(diff(rango_c) == 0, 1, diff(rango_m) / diff(rango_c))
  offset_ce <- rango_m[1] - rango_c[1] * factor_escala
  
  dfp <- dfp %>%
    mutate(
      var_m_original = !!sym(var_meteo),
      var_ce_escalada = (!!sym(var_ce)) * factor_escala + offset_ce
    )
  
  # Mapa de colores universal para TODAS las figuras
  color_universal <- c(
    "Precipitación"          = "#7fc9ff",
    "Velocidad del Viento"   = "#6bbf59",
    "Temperatura del Aire"   = "#ff9f40",
    "Conductividad Eléctrica"= "#000000"
  )
  
  # Selección de colores para este gráfico
  color_map_local <- color_universal[c(nombre_m, nombre_c)]
  
  # plot
  p <- ggplot(dfp, aes(x = fecha)) +
    
    # meteorológica
    geom_line(aes(y = var_m_original, color = nombre_m), linewidth = 1.3, na.rm = TRUE) +
    
    # CE escalada
    geom_line(aes(y = var_ce_escalada, color = nombre_c), linewidth = 1.1, na.rm = TRUE) +
    
    scale_y_continuous(
      name = lbl_m["nombre_completo"],
      sec.axis = sec_axis(~ (. - offset_ce) / factor_escala,
                          name = lbl_c["nombre_completo"])
    ) +
    
    # Usamos el mismo mapa para TODAS las figuras:
    scale_color_manual(values = color_map_local, drop = TRUE) +
    
    labs(
      title = paste("Comparación:", nombre_m, "vs", nombre_c),
      subtitle = subtitulo,
      x = NULL,
      color = NULL
    ) +
    
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      plot.subtitle = element_text(size = 14, color = "gray40", hjust = 0.5, face = "italic"),
      legend.position = "bottom",
      legend.text = element_text(size = 12),
      axis.text.x = element_text(size = 14),
      panel.grid.minor = element_blank()
    ) +
    
    scale_x_date(
      date_breaks = "1 month",
      date_labels = "%B",
      expand = expansion(add = c(0, 0.5))
    )
  return(p)
}

# ============================================================================
# GENERAR GRÁFICOS
# ============================================================================
graficos_series <- list()
for (v in columnas_meteo) {
  if (!v %in% names(datos_diarios)) {
    warning("Variable faltante: ", v); next
  }
  try({
    p <- crear_series_temporales(datos_diarios, v, columnas_ce)
    if (!is.null(p)) {
      # forzamos una leyenda en una fila (por si el label es largo)
      p <- p + guides(color = guide_legend(nrow = 1, byrow = TRUE))
      # asegurar que la leyenda esté abajo en este panel
      p <- p + theme(legend.position = "bottom", legend.title = element_blank())
      graficos_series[[v]] <- p
    }
  }, silent = TRUE)
}

# ============================================================================
# COMBINAR Y GUARDAR FIGURA
# ============================================================================
plots_ordered <- graficos_series[intersect(columnas_meteo, names(graficos_series))]

panel_completo <- wrap_plots(plots_ordered, ncol = 1)

ggsave("04_Series_Temporales_Superpuestas.png", panel_completo, width = 14, height = 5 * length(plots_ordered), dpi = 300)

```

#### *Análisis de correlación*

Para desarrollar el análisis de correlación entre variables se aplicó el siguiente procedimiento:

1.  Carga de librerías
2.  Preparación de datos: asegurar que no existan valores "NA" y que las columnas sean numéricas
3.  Aplicación de correlación de Pearson con los datos completos, mostrando unicamente la mitad de los cruces para evitar redundancia
4.  Cálculo de significancia a través de p-values
5.  Creación de matriz con sus respectivos valores de correlación y nivel de significancia

![](figuras/Figura3_Matriz_de_correlacion.png)

```{r}
# MATRIZ DE CORRELACIÓN
# Se usó stackoverflow y chatgpt para desarrollar el código
# Se utilizó chatgpt para depurar, ordenar, modificar y optimizar los códigos propuestos inicialmente

library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)

# ============================================================================
# PREPARAR DATOS
# ============================================================================
vars_interes <- c("mm_precipitation", "m_s_wind_speed", "c_air_temperature", "m_s_cm_ec")

# Extraer datos (ASUMIMOS que no hay NA en datos_diarios) ----
df_corr <- datos_diarios %>% select(any_of(vars_interes)) %>% mutate(across(everything(), ~ as.numeric(.)))

# Chequeo (si hay NA abortamos porque pediste no usar pairwise) 
if (any(is.na(df_corr))) stop("Se detectaron NA en 'df_corr'. Este script usa 'complete.obs' (no pairwise). Revisa tus datos.")

# Imprimir info básica
cat("Filas en datos_diarios:", nrow(datos_diarios), "\n")
cat("Filas usadas para correlación (sin NA):", nrow(df_corr), "\n\n")

# ============================================================================
# CORRELACION USANDO complete.obs 
# ============================================================================
metodo <- "pearson"
corr_mat <- cor(df_corr, use = "complete.obs", method = metodo)

# p-values: cor.test sobre los vectores completos (sin NA)
vars <- colnames(df_corr)
n <- length(vars)
p_mat <- matrix(NA, nrow = n, ncol = n, dimnames = list(vars, vars))
for (i in seq_len(n)) {
  for (j in seq_len(n)) {
    if (i == j) {
      p_mat[i, j] <- 0
    } else {
      xi <- df_corr[[vars[i]]]
      xj <- df_corr[[vars[j]]]
      # cor.test en vectores completos (sin NA por la verificación anterior)
      test <- tryCatch(cor.test(xi, xj, method = metodo), error = function(e) NULL)
      p_mat[i, j] <- if (!is.null(test)) test$p.value else NA
    }
  }
}

# Mostrar correlaciones y p-values respecto a CE
cat("Correlaciones (", metodo, ") con m_s_cm_ec:\n", sep = "")
print(round(corr_mat["m_s_cm_ec", ], 3))
cat("\nP-values (m_s_cm_ec vs):\n")
print(round(p_mat["m_s_cm_ec", ], 4))
cat("\n")

# Cambio de nombres
nice_names <- c(
  mm_precipitation  = "Precipitación (mm)",
  m_s_wind_speed    = "Velocidad del Viento (m/s)",
  c_air_temperature = "Temperatura del Aire (°C)",
  m_s_cm_ec         = "Conductividad (mS/cm)"
)

common_vars <- intersect(colnames(corr_mat), names(nice_names))
corr_mat_named <- corr_mat[common_vars, common_vars, drop = FALSE]
p_mat_named    <- p_mat[common_vars, common_vars, drop = FALSE]
rownames(corr_mat_named) <- colnames(corr_mat_named) <- nice_names[common_vars]
rownames(p_mat_named)    <- colnames(p_mat_named)    <- nice_names[common_vars]

# Clustering jerárquico para orden (basado en |r|)
temp <- corr_mat_named
dist_mat <- as.dist(1 - abs(temp))   # distancia = 1 - |r|
hc <- hclust(dist_mat)
vars_ordered <- hc$labels[hc$order]

# Construir dataframe para ggplot (triángulo inferior)
corr_df <- as.data.frame(corr_mat_named) %>%
  tibble::rownames_to_column(var = "Var1") %>%
  pivot_longer(-Var1, names_to = "Var2", values_to = "r") %>%
  mutate(
    Var1 = factor(Var1, levels = vars_ordered),
    Var2 = factor(Var2, levels = vars_ordered),
    p_value = as.vector(p_mat_named[cbind(as.character(Var1), as.character(Var2))])
  ) %>%
  filter(as.integer(Var1) > as.integer(Var2))   # mantener sólo triángulo inferior

# Etiquetas y asteriscos de significancia
corr_df <- corr_df %>%
  mutate(
    r_label = ifelse(is.na(r), "", sprintf("%.2f", r)),
    signif = case_when(
      is.na(p_value) ~ "",
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

# Paleta y plot
pal <- c("#b2182b", "white", "#2166ac")  # rojo-blanco-azul

p_heat <- ggplot(corr_df, aes(x = Var2, y = Var1)) +
  geom_tile(aes(fill = r), color = "grey80", width = 0.95, height = 0.95) +
  scale_fill_gradient2(low = pal[1], mid = pal[2], high = pal[3],
                       midpoint = 0, limits = c(-1, 1), oob = scales::squish, name = "") + # name="" elimina "Corr"
  geom_text(aes(label = r_label), size = 4, color = "black") +
  geom_text(aes(label = signif), size = 5, color = "black", vjust = -1.2) + # asteriscos arriba del número
  coord_fixed() +
  labs(title = paste0("Matriz de correlación (", toupper(metodo), ")")) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    panel.grid = element_blank(),
    legend.position = "right"
  )

# Guardar
ggsave("04_Corr_Heatmap_CompleteObs.png", p_heat, width = 8, height = 6, dpi = 300)

```

## Conclusiones

-   La CE presenta variabilidad mensual marcada, con aumentos notorios en ciertos periodos del año, evidenciando influencia estacional.

-   Los boxplots mensuales muestran alta dispersión en algunos meses, sugiriendo eventos puntuales de salinización o fluctuaciones abruptas en el contenido de sales.

-   Las series temporales permiten identificar tendencias y pulsos donde la CE aumenta bajo condiciones atmosféricas específicas, evidenciando una respuesta compleja del suelo.

-   En periodos de baja precipitación y mayor estabilidad atmosférica, la CE tiende a aumentar, coherente con procesos de evaporación y concentración de solutos.

-   La matriz de correlación muestra que la CE está negativamente correlacionada con la precipitación, reforzando su rol como indicador de procesos de lavado de sales.

-   La correlación con la temperatura puede ser positiva o débil, según periodo y contexto, reflejando una relación indirecta con evapotranspiración y concentración de solutos.

-   La CE se confirma como un indicador sensible de la dinámica hídrica del suelo, especialmente para los procesos de evaporación–lixiviación y la disponibilidad de agua.
